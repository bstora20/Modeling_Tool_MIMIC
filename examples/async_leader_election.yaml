# Asynchronous Leader Election (Event-Driven)
# 4 nodes with values 1, 3, 5, 8
# Connections: 1->3, 3->5, 3->8, 5->1, 5->3, 8->1
# Nodes send messages asynchronously when they update their max value
# Leader is the node with the highest value (should be 8)

component:
  name: AsynchronousLeaderElection
  type: asynchronous
  
  state:
    # Node values (original IDs)
    node_1_value: 1
    node_3_value: 3
    node_5_value: 5
    node_8_value: 8
    
    # Current max known by each node
    node_1_max: 1
    node_3_max: 3
    node_5_max: 5
    node_8_max: 8
    
    # Track if each node updated in the last check period
    node_1_updated: false
    node_3_updated: false
    node_5_updated: false
    node_8_updated: false
    
    # Node status (leader or follower)
    node_1_status: "unknown"
    node_3_status: "unknown"
    node_5_status: "unknown"
    node_8_status: "unknown"
    
    # Leader election status
    leader: null
    election_complete: false
    messages_sent: 0
    stability_checks: 0
  
  inputs: []
  
  outputs:
    - leader
    - messages_sent
    - node_states
    - node_statuses
  
  tasks:
    # Initialize: Each node sends its initial value to neighbors
    - name: initialize
      trigger:
        type: immediate
      code: |
        print(f"[{current_time:.2f}s] Initializing election")
        print(f"Initial states: 1={state.node_1_max}, 3={state.node_3_max}, 5={state.node_5_max}, 8={state.node_8_max}")
        
        # Each node sends its initial value
        emit_event("send_from_1", delay=0.1)
        emit_event("send_from_3", delay=0.15)
        emit_event("send_from_5", delay=0.12)
        emit_event("send_from_8", delay=0.18)
        
        # Start periodic stability checks
        emit_event("stability_check", delay=1.0)
    
    # Node 1 sends to its neighbors (3)
    - name: send_from_1
      trigger:
        type: event
        event: send_from_1
      code: |
        print(f"[{current_time:.2f}s] Node 1 -> Node 3: {state.node_1_max}")
        emit_event("receive_at_3", data={'value': state.node_1_max, 'from': 1}, delay=0.05)
        state.messages_sent += 1
    
    # Node 3 sends to its neighbors (5, 8)
    - name: send_from_3
      trigger:
        type: event
        event: send_from_3
      code: |
        print(f"[{current_time:.2f}s] Node 3 -> Node 5: {state.node_3_max}")
        print(f"[{current_time:.2f}s] Node 3 -> Node 8: {state.node_3_max}")
        emit_event("receive_at_5", data={'value': state.node_3_max, 'from': 3}, delay=0.05)
        emit_event("receive_at_8", data={'value': state.node_3_max, 'from': 3}, delay=0.05)
        state.messages_sent += 2
    
    # Node 5 sends to its neighbors (1, 3)
    - name: send_from_5
      trigger:
        type: event
        event: send_from_5
      code: |
        print(f"[{current_time:.2f}s] Node 5 -> Node 1: {state.node_5_max}")
        print(f"[{current_time:.2f}s] Node 5 -> Node 3: {state.node_5_max}")
        emit_event("receive_at_1", data={'value': state.node_5_max, 'from': 5}, delay=0.05)
        emit_event("receive_at_3", data={'value': state.node_5_max, 'from': 5}, delay=0.05)
        state.messages_sent += 2
    
    # Node 8 sends to its neighbors (1)
    - name: send_from_8
      trigger:
        type: event
        event: send_from_8
      code: |
        print(f"[{current_time:.2f}s] Node 8 -> Node 1: {state.node_8_max}")
        emit_event("receive_at_1", data={'value': state.node_8_max, 'from': 8}, delay=0.05)
        state.messages_sent += 1
    
    # Node 1 receives a message
    - name: receive_at_1
      trigger:
        type: event
        event: receive_at_1
      code: |
        # Extract value from event_data (handle double-wrapped data)
        try:
            if isinstance(event_data, dict):
                # Check if data is double-wrapped
                if 'value' in event_data and isinstance(event_data['value'], dict):
                    data = event_data['value']
                else:
                    data = event_data
                
                value = data.get('value')
                sender = data.get('from')
            else:
                value = None
                sender = None
            
            if value is not None and isinstance(value, int) and value > state.node_1_max:
                print(f"[{current_time:.2f}s] Node 1 updated: {state.node_1_max} -> {value} (from Node {sender})")
                state.node_1_max = value
                state.node_1_updated = True  # Mark that this node updated
                # Send updated value to neighbors
                emit_event("send_from_1", delay=0.1)
        except Exception as e:
            print(f"Error in receive_at_1: {e}, event_data type: {type(event_data)}, value: {event_data}")
        
        emit_event("check_completion", delay=0.01)
    
    # Node 3 receives a message
    - name: receive_at_3
      trigger:
        type: event
        event: receive_at_3
      code: |
        # Extract value from event_data (handle double-wrapped data)
        try:
            if isinstance(event_data, dict):
                # Check if data is double-wrapped
                if 'value' in event_data and isinstance(event_data['value'], dict):
                    data = event_data['value']
                else:
                    data = event_data
                
                value = data.get('value')
                sender = data.get('from')
            else:
                value = None
                sender = None
            
            if value is not None and isinstance(value, int) and value > state.node_3_max:
                print(f"[{current_time:.2f}s] Node 3 updated: {state.node_3_max} -> {value} (from Node {sender})")
                state.node_3_max = value
                state.node_3_updated = True  # Mark that this node updated
                # Send updated value to neighbors
                emit_event("send_from_3", delay=0.1)
        except Exception as e:
            print(f"Error in receive_at_3: {e}, event_data type: {type(event_data)}, value: {event_data}")
        
        emit_event("check_completion", delay=0.01)
    
    # Node 5 receives a message
    - name: receive_at_5
      trigger:
        type: event
        event: receive_at_5
      code: |
        # Extract value from event_data (handle double-wrapped data)
        try:
            if isinstance(event_data, dict):
                # Check if data is double-wrapped
                if 'value' in event_data and isinstance(event_data['value'], dict):
                    data = event_data['value']
                else:
                    data = event_data
                
                value = data.get('value')
                sender = data.get('from')
            else:
                value = None
                sender = None
            
            if value is not None and isinstance(value, int) and value > state.node_5_max:
                print(f"[{current_time:.2f}s] Node 5 updated: {state.node_5_max} -> {value} (from Node {sender})")
                state.node_5_max = value
                state.node_5_updated = True  # Mark that this node updated
                # Send updated value to neighbors
                emit_event("send_from_5", delay=0.1)
        except Exception as e:
            print(f"Error in receive_at_5: {e}, event_data type: {type(event_data)}, value: {event_data}")
        
        emit_event("check_completion", delay=0.01)
    
    # Node 8 receives a message
    - name: receive_at_8
      trigger:
        type: event
        event: receive_at_8
      code: |
        # Extract value from event_data (handle double-wrapped data)
        try:
            if isinstance(event_data, dict):
                # Check if data is double-wrapped
                if 'value' in event_data and isinstance(event_data['value'], dict):
                    data = event_data['value']
                else:
                    data = event_data
                
                value = data.get('value')
                sender = data.get('from')
            else:
                value = None
                sender = None
            
            if value is not None and isinstance(value, int) and value > state.node_8_max:
                print(f"[{current_time:.2f}s] Node 8 updated: {state.node_8_max} -> {value} (from Node {sender})")
                state.node_8_max = value
                state.node_8_updated = True  # Mark that this node updated
                # Send updated value to neighbors
                emit_event("send_from_8", delay=0.1)
        except Exception as e:
            print(f"Error in receive_at_8: {e}, event_data type: {type(event_data)}, value: {event_data}")
        
        emit_event("check_completion", delay=0.01)
    
    # Periodic stability check - if no nodes updated since last check, system is stable
    - name: stability_check
      trigger:
        type: event
        event: stability_check
      code: |
        if not state.election_complete:
            state.stability_checks += 1
            
            # Check if any node updated since last check
            any_updates = (state.node_1_updated or state.node_3_updated or 
                          state.node_5_updated or state.node_8_updated)
            
            if any_updates:
                print(f"[{current_time:.2f}s] Stability check #{state.stability_checks}: Updates detected, continuing...")
                # Reset update flags for next check
                state.node_1_updated = False
                state.node_3_updated = False
                state.node_5_updated = False
                state.node_8_updated = False
                # Schedule next check
                emit_event("stability_check", delay=1.0)
            else:
                # No updates detected - system is stable, election complete
                print(f"[{current_time:.2f}s] Stability check #{state.stability_checks}: No updates - system stable!")
                emit_event("finalize_election", delay=0.0)
    
    # Finalize election when stable state is detected
    - name: finalize_election
      trigger:
        type: event
        event: finalize_election
      code: |
        max_val = max(state.node_1_max, state.node_3_max, state.node_5_max, state.node_8_max)
        
        # Each node determines its own status
        state.node_1_status = "leader" if state.node_1_value == max_val else "follower"
        state.node_3_status = "leader" if state.node_3_value == max_val else "follower"
        state.node_5_status = "leader" if state.node_5_value == max_val else "follower"
        state.node_8_status = "leader" if state.node_8_value == max_val else "follower"
        
        state.election_complete = True
        state.leader = max_val
        
        print(f"\n[{current_time:.2f}s] *** ELECTION COMPLETE ***")
        print(f"Leader elected: Node {state.leader}")
        print(f"Total messages sent: {state.messages_sent}")
        print(f"Detected via stable state after {state.stability_checks} checks")
        print(f"\nNode Statuses:")
        print(f"  Node 1: {state.node_1_status} (knows max={state.node_1_max})")
        print(f"  Node 3: {state.node_3_status} (knows max={state.node_3_max})")
        print(f"  Node 5: {state.node_5_status} (knows max={state.node_5_max})")
        print(f"  Node 8: {state.node_8_status} (knows max={state.node_8_max})")
        
        outputs.leader = state.leader
        outputs.messages_sent = state.messages_sent
        outputs.node_states = {
            'node_1': state.node_1_max,
            'node_3': state.node_3_max,
            'node_5': state.node_5_max,
            'node_8': state.node_8_max
        }
        outputs.node_statuses = {
            'node_1': state.node_1_status,
            'node_3': state.node_3_status,
            'node_5': state.node_5_status,
            'node_8': state.node_8_status
        }
